# overview
refer to the interface and data flow diagram.

## system characteristic
long-lived connections are established and maintained between clients and servers for passing around messages. given that each client comes online randomly, it is then the quantity of such connections that matter the most, in terms of mounting system pressure. so a strategy based on the number of connections should be devised in order to maintain and balance load among servers.

# modules
there're 3 modules in general, including messaging, queue, and tag, but they could be divided into more granularity suited for cloud deployment and for better scalability.

## messaging module

### channel types
* push        - one-off notification, from server to mobile devices
* web socket  - two-way connection, initiated by client, lasting for an extended period of time

### message types
* notification - instruction or information that business pass out to clients, through either push or web socket channel
* chat         - message from one client to another one or multiple clients, through web socket channel
* ???? message - TBD other types of user or control messages, through web socket channel

### message protocols
TBD - define message formats or protocols for client and server to communicate with, or for messages to be routed within modules. e.g. to specify message type/content/source/destination/expiry/require status report/etc. this protocol should not be mk specific. in fact, the whole system should be built without the knowledge of specific business terms.

### message sources
* from queue module, e.g. notification
* from clients, e.g. chat

### message storage
temporarily store messages uploaded from queue module or sent by clients, removed upon delivery, conditionally update delivery status, auto expiration, etc.
TBD - define storage format, state, and process flow diagram(of process unit).

### message translator
from tagged message to expanded messages - business would upload mostly tagged messages, which would be later expanded to address to specific recipients.
from general message to channel messages - upon delivery, a general message gets translated into channel specific one, e.g. Apple push notification

### module scope
TBD - is push channel already existed?

### interface to queue module
* upload messages - uploaded tagged messages generated by business will be processed immediately, preferably through web socket channel, if not available then through push channel.
* query status    - queue module use to query delivery status if the message uploaded marked as require status report. e.g. a tagged message would probably like to know how many final recipients there should be and how many are delivered and how many are opened, etc. TBD - more detailed feedback process and definition.

### interface to client
* request new web socket channel with web socket load balancer(TBD limit to no more than 1 connections allowed from the same ip?)
* establish assigned web socket channel with one of the front web socket workers

### interaction with client
* send out messages through proper channels

### interaction with tag module
* expand tagged messages, call upon the tag module to expand a tagged message into a more concrete message bundle
(implying a two-level, abstract-concrete message storage hierarchy?)

### interface authentication
* with client       - ??? with load balancer; token based authentication with front workers.
* with queue module - virtual network rule based security
* with tag module   - virtual network rule based security
* with business     - ???
TBD - define authentication details

### major prototypes
topology for establishing and load balancing web socket connections, involving client - balancer - front worker
balancer characteristics:
* be aware of front worker load, assign load based on front worker's active connections with clients
* be aware of front worker's topology changes(worker removed, worker added)

### components
balancer - contains client api
front worker - contains client api
storage - contains queue api
processing unit - connect storage, balancer, and front worker in order to direct message flow

## queue module
accept messages from business, schedule delivery to messaging module, and collecting delivery status.

### message types
message addressed to specific recipients
message addressed to some tags
message addressed to some tag combination, e.g. tag_A + tag_B, tag_A - tag_B

### queue storage
* store tagged message
* store tagged message delivery status

### processing unit
* schedule massage upload
* pull message delivery status
* other massage status, storage maintenance

### interface to business
upload message - allow business to upload tagged message, specify priority, time to send, etc.
cancel message - only those messages which have not been uploaded to messaging module are allowed to be canceled.
prioritize message - update uploaded message's priority field
query message delivery status - query uploaded message's delivery status, sent/not sent/delivery percentage/expansion count/etc.

### interaction with messaging module
upload message - when the tagged message is due for delivery, upload it for immediate processing and sending
query message delivery status - query and update message delivery status

### interaction with tag module
validate tags - upon uploading message, perform message tag consistency check. e.g. a specific tag might be deleted, mark delivery status accordingly.

## tag module
maintain tag to address mappings

### tag storage
* store tag - address mapping(it's better to use an immutable data structure, since a tag might be in used while attempting to update it)
* store tag meta data

### interface to business
manipulate tag - tag create/update/delete/etc.
tag operation - create tag alias, tag combination, etc.
manipulate current mapping - manage tag - address mapping, is it possible for business to upload a mapping delta? e.g. mk ibc's levels might be affected at the end of each month based on their performance, therefore the level tag will require mapping updates. it will be easier if mk could provide such delta of affected ibcs.

### interface to queue module
validate tags

### interface to messaging module
validate tags
expand tag - expand a single tag or a combination of tags into detailed addresses
(for performance sake, might want give messaging module direct access to an immutable tag mapping, allowing the expansion process extra fault tolerance or performance)

### major prototypes
immutable data structure for storing and accessing tag - address mappings

# timeline & estimation
* concept and topology prototyping
* interface and boundary should be prioritized
* fast and continuous test & deployment facilities

# dev iteration and output
TBD
